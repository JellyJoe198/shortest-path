# __Best Path: Mountain Hiking__
Author: Joseph Brownlee (jmbrownlee@mines.edu)  
Motivation: initially final project for CSCI261C at CSM, continued developent for personal use.  

# Problem Description
I want to calculate the best path to take when hiking up a mountain. The shortest absolute path between two points on a plane is obviously a straight line, but that path on a 3D surface is a little more complicated to find. My program finds a first approximation of that best path, also taking into account height to avoid slopes that are too steep to hike.  

# Program Documentation

## How to run the program
0) ensure your surface file is in the same directory as the program, and that your computer is capable of running the program, including compatability with SFML. Build c++ code with Cmake if necessarry.
1) run program and follow input prompts
    - input the name of your surface file  
    - input your height intolerance coefficient: 1 means you can travel vertically just as easily as horizontal; higher numbers generally result in a longer, but less steep path.  
    - input start and end coordinates: you must input 2 numbers separated by whitespace for each coordinate. (4 numbers in total)  
    - see in the console your surface and the path
    - see in an SFML window:
        - the surface, with a key on the righthand side of the window to show how hue relates to height.  
        - on any key press: the path the program found between those two points will be shown. Pressing again will overlay it onto the surface, with the colors darkened to identify pixels that are part of path without obstructing height data.  

## Additional features to add later
- reading from huge hgt files: this would require an upgrade of the `readSurface()` function to not require spaces between each value, and likely an upgrade in the memory management in `World::_surface` to allow more data to be stored.
- taking start and end coordinates from clicks in an SFML window instead of text coordinates: this should be relatively simple to implement, you just have to add an event for clicking and send the mouse position to the shortPath function, then display again.

# Test Cases
There are a few verifications in place to warn the user when surface files are malformed.  
To test different uses of the program, you can play around with different numbers in the start/end coordinates and see different results. You can also change the surface file.  

## different surfaces
Included in the project are a few sample surface files. The mazes were used to test height coefficients and to definitively see if it found the shortest path. `testSurface1w` is invalid to test the error collection.

The other test surfaces were generated by `surface generator.py`. These used a math equation, but the program would also work on real world data assuming it is formatted properly and small enough that memory is not an issue. Below is a list of the equations used to generate test surfaces 1 and 2, in the format:   
- row[start,end];col[start,end] ; equation   #comment  
with pow(base,exponent); row = current row; and col = current column.   
The equations:  
- row[5,15];col[0,14] ; pow(col - 5, 1.5) * (-.1) + row  # inverse parabola  
- row[5,15];col[0,14] ; pow(col - 5, 2) * (-.2) + row   # larger inverse parabola  

Each of those equations was then run through the following equation to represent the surface as unsigned integers:   
abs(int(value*1000))   #note: abs() makes everything positive, so the end graph may not look exactly parabolic.  


# Reflections
_someone didn't know how to use pointers properly_  

In this project I strengthened my knowledge of classes, and practiced debugging (and working around) strange issues, such as template instantiation in the point class. If I were to do it differently I would have started earlier, and thoroughly talked through this program (with a real person) before starting the implementation. This is because I had challenges with finding an algorithm that would find the shortest path. My final solution uses the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm), but before I discovered that I went down a rabbit hole of parameterized best fit curves and minimizing based on [gradient descent](https://meshlogic.github.io/posts/jupyter/curve-fitting/parametric-curve-fitting/), which is both way above my current mathematics skill and unneccessarily complex for this program. This wasted a lot of my time because I wrote a bunch of math functions that went unused in the final program.  
Overall, this program was a good stress test of my programming skills, and it gave me a good opportunity to research different path finding algorithms, some of which may be relevant to modern robotics or in mapping electrical circuits.  

## Acknowledgements  
During this project I had help from the following people:  

- __Dr. Jeffrey Paone__ - programming concepts CSCI261, and a few questions on Piazza.    
- __Student Glenn Moore__ - Got me out of the calculus rabbit hole: A*_algorithm discussion (abstract pseudocode only), memory efficiency discussion around storing nodes, and max precision calculations.  
