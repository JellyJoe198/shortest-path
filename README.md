# __Best Path: Mountain Hiking__
This is a final project done by Joseph Brownlee (jmbrownlee@mines.edu) in CSCI261C at CSM.

# Problem Description
I want to calculate the best path to take when hiking up a mountain. The shortest absolute path between two points on a plane is obviously a straight line, but that path on a 3D surface is a little more complicated to find. My program finds a first approximation of that best path, also taking into account height to avoid slopes that are too steep to hike.  

# Program Documentation

## How to run the program
0) ensure your surface file is in the same directory as the program, and that your computer is capable of running the program, including compatability with SFML
1) run program and follow input prompts
    - the name of your surface file (disabled for debugging)  
    + see a processed version of your surface file in the console
    - start and end coordinates: you must input 2 numbers separated by whitespace for each coordinate. (4 numbers in total)  
    - *not implemented yet but trivial to implement:* input your height intolerance coefficient: 1 means you can travel vertically just as easily as horizontal; higher numbers generally result in a longer, but less steep path.  
    + see the path it found between those two points (not working, A* algorithm not calibrated)

## Aadditional features to add later
- reading from huge hgt files: this would require an upgrade of the `readSurface()` function to not require spaces between each value, and likely an upgrade in the memory management in `World::_surface` to allow more data to be stored.
- displaying surface in SFML window
 - taking start and end coordinates from clicks in an SFML window instead of text coordinates: this should be relatively simple to implement, you just have to add an event for clicking and send the mouse position to the shortPath function, then display again.

# Test Cases
There are a few verifications in place to warn the user when surface files are malformed. Unfortunately I did not have enough time to fix all the bugs in the program (especially in the A* algorithm as that is the most recent addition). 

To test different uses of the program, you can play around with different numbers in the start/end coordinates and see different results. You can also change the surface file.  

## different surfaces
Included in the project are some sample surface files generated by `surface generator.py`. These were generated by a math equation, but it would also work on real world data assuming it is formatted properly and small enough that memory is not an issue. Below is a list of the equations used to generate the test surfaces, in the format:
- row[start,end];col[start,end] ; equation   #comment
with pow(base,exponent); row = current row; and col = current column.
The equations:  
- row[5,15];col[0,14] ; pow(col - 5, 1.5) * (-.1) + row  # inverse parabola
- row[5,15];col[0,14] ; pow(col - 5, 2) * (-.2) + row   # larger inverse parabola

Each of those equations was then run through the following equation to represent the surface as unsigned integers:  
abs(int(value*1000))   #note: abs() makes everything positive, so the end graph may not look exactly parabolic.


# Reflections
_someone didn't know how to use pointers properly_  

In this project I strengthened my knowledge of classes, and practiced debugging (and working around) strange issues, such as template instantiation in the point class. If I were to do it differently I would have started earlier, and thoroughly talked through this program (with a real person) before starting the implementation. This is because I had challenges with finding an algorithm that would find the shortest path. My final solution uses the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm), but before I discovered that I went down a rabbit hole of parameterized best fit curves and minimizing based on [gradient descent](https://meshlogic.github.io/posts/jupyter/curve-fitting/parametric-curve-fitting/), which is both way above my current mathematics skill and unneccessarily complex for this program. This wasted a lot of my time because I wrote a bunch of math functions that went unused in the final program.  
Overall, this program was a good stress test of my programming skills, and it gave me a good opportunity to research different path finding algorithms, some of which may be relevant to modern robotics or in mapping electrical circuits.

## Acknowledgements  
During this project I had help from the following people:  

- __Dr. Jeffrey Paone__ - programming concepts CSCI261, and a few questions on Piazza.    
- __Student Glenn Moore__ - Got me out of the calculus rabbit hole: A*_algorithm discussion (abstract pseudocode only), memory efficiency discussion around storing nodes, and max precision calculations.  
